# -*- coding: utf-8 -*-
"""Sales Forecasting

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1jd4sqHo2z2OTFZoYUgSdsY62HCzREfv1
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
from feature_engine.datetime import DatetimeFeatures
from feature_engine.timeseries.forecasting import LagFeatures
from sklearn.preprocessing import MinMaxScaler

import warnings
warnings.filterwarnings("ignore")

data = pd.read_csv("/content/store5.csv")

data.head()

data = data.drop(columns=["id","dcoilwtico"])

data.info()

data['date'] = pd.to_datetime(data['date'])
data['raw_date'] = pd.to_datetime(data['date'])

data = data.set_index('date')

data['date'] = data['raw_date']
data = data.drop(columns=['raw_date'])

data

print('Jumlah kategori produk : ',len(data['family'].unique()))
data['family'].value_counts()

for col in data.columns:
  null_data     = data[data[col].isnull()]
  filled_data   = data[data[col].isnull() == False]
  percentage_null = (len(null_data) / len(data)) * 100
  print(col,len(null_data),len(filled_data),percentage_null)

def plot_this(x,y,title= None,color = None):
  # Create the plot
  plt.figure(figsize=(48, 6))
  plt.plot(x, y, color=(color or 'b'))

  # Add title and labels
  plt.title(f"Line Plot {title or 'Data'}")
  plt.xticks(rotation=90)

  # Show the plot
  plt.grid(True)
  plt.show()

plot_this(data.index,data['sales'],f"full-date",'red')

def get_family_data(family=None,period=None):
  if family == None:
    return []

  family_data = data[data['family'] == family]

  if period == 'W':
    new_data = family_data.resample('W-MON').agg(
      sales=('sales', 'sum'),
      family=('family', 'first'),
      onpromotion=('onpromotion', 'sum')
    ).reset_index()
  elif period == 'M':
    new_data = family_data.resample('M').agg(
      sales=('sales', 'sum'),
      family=('family', 'first'),
      onpromotion=('onpromotion', 'sum')
    ).reset_index()
  elif period == 'Q':
    new_data = family_data.resample('Q').agg(
      sales=('sales', 'sum'),
      family=('family', 'first'),
      onpromotion=('onpromotion', 'sum')
    ).reset_index()
  else:
    new_data = family_data.resample('W-MON').agg(
      sales=('sales', 'sum'),
      family=('family', 'first'),
      onpromotion=('onpromotion', 'sum')
    ).reset_index()

  return new_data

for family in data['family'].unique():
  fam_data_weekly     = get_family_data(family,'W')
  plot_this(fam_data_weekly['date'],fam_data_weekly['sales'],f"{family} weekly",'red')

familyScope = ['AUTOMOTIVE', 'BEAUTY', 'CLEANING', 'EGGS','DAIRY', 'DELI', 'LINGERIE', 'MEATS', 'PREPARED FOODS', 'FROZEN FOODS']

for family in data['family'].unique():
  if family in familyScope:
    fam_data_weekly     = get_family_data(family,'W')
    fam_data_monthly    = get_family_data(family,'M')
    fam_data_quarterly  = get_family_data(family,'Q')
    plot_this(fam_data_weekly['date'],fam_data_weekly['sales'],f"{family} weekly",'red')
    plot_this(fam_data_monthly['date'],fam_data_monthly['sales'],f"{family} monthly",'green')
    plot_this(fam_data_quarterly['date'],fam_data_quarterly['sales'],f"{family} quarterly",'blue')

def get_filtered_family_data(family,filter_since=None,filter_until=None,period=None):

  filtered_data = get_family_data(family,period)

  if filter_since != None:
    filter_date_since = pd.to_datetime(filter_since)
    filtered_data = filtered_data[(filtered_data['date'] > filter_date_since)]

  if filter_until != None:
    filter_date_until = pd.to_datetime(filter_until)
    filtered_data = filtered_data[(filtered_data['date'] < filter_date_until)]

  filtered_data = filtered_data[(filtered_data['sales'] > 0)]

  return filtered_data

def generate_filtered_data():

  filtered_data = {}

  for family in data['family'].unique():
    if family in familyScope:

      fam_data = get_filtered_family_data(family,None,'2017-12-31','W').reset_index()
      fam_data = fam_data[fam_data.index < len(fam_data.index) - 1]

      filtered_data[family] = fam_data

  return filtered_data

filtered_data = generate_filtered_data()

for family in data['family'].unique():
  if family in familyScope:
    plot_this(filtered_data[family]['date'],filtered_data[family]['sales'],f"{family} w",'blue')

from statsmodels.graphics.tsaplots import plot_acf, plot_pacf
from statsmodels.tsa.stattools import adfuller

def adf_test(series):
    result = adfuller(series)
    print(f'ADF Statistic: {result[0]}')
    print(f'p-value: {result[1]}')
    if result[1] <= 0.05:
      print("\033[91mThe series is stationary \033[0m")
    else:
      print("The series is not stationary")

for family in familyScope:
  print(f"\n-----------{family}----------\n")

  family_data = filtered_data[family]['sales'].dropna()

  adf_test(family_data)
  fig, ax = plt.subplots(1, 2, figsize=(20, 6))
  plot_acf(family_data, lags=8,ax=ax[0])
  plot_pacf(family_data, lags=8,ax=ax[1])
  plt.show()

for family in familyScope:
  print(f"\n-----------{family} DIFF 1----------\n")

  family_data = filtered_data[family]['sales'].diff().dropna()

  adf_test(family_data)
  fig, ax = plt.subplots(1, 2, figsize=(20, 6))
  plot_acf(family_data, lags=7,ax=ax[0])
  plot_pacf(family_data, lags=7,ax=ax[1])
  plt.show()

# 'AUTOMOTIVE', 'BEAUTY', 'CLEANING', 'EGGS', 'HARDWARE', 'LINGERIE', 'MEATS', 'PREPARED FOODS', 'FROZEN FOODS'

p = {
    'AUTOMOTIVE':3,
    'BEAUTY': 5,
    'CLEANING':3,
    'EGGS':3,
    'LINGERIE':1,
    'MEATS':3,
    'DAIRY':3,
    'DELI':3,
    'PREPARED FOODS':3,
    'FROZEN FOODS':3,
}

q = {
    'AUTOMOTIVE':1,
    'BEAUTY':1,
    'CLEANING':1,
    'EGGS':1,
    'LINGERIE':1,
    'MEATS':1,
    'DELI':1,
    'DAIRY':1,
    'PREPARED FOODS':1,
    'FROZEN FOODS':3,
}

d = {
    'AUTOMOTIVE':1,
    'BEAUTY': 1,
    'CLEANING':1,
    'EGGS':1,
    'LINGERIE':1,
    'MEATS':1,
    'DELI':1,
    'DAIRY':1,
    'PREPARED FOODS':1,
    'FROZEN FOODS':1,
}

is_seasonal = {
    'AUTOMOTIVE':False,
    'BEAUTY': False,
    'CLEANING':False,
    'EGGS':False,
    'LINGERIE':False,
    'MEATS':False,
    'DAIRY':False,
    'DELI':False,
    'PREPARED FOODS':False,
    'FROZEN FOODS':True
}

from statsmodels.tsa.arima.model import ARIMA
from sklearn.metrics import mean_squared_error

def prepare_train_data_for(family):
  data_to_train = filtered_data[family]

  train_size = int(len(data_to_train)*0.8)

  data_to_train = data_to_train.set_index('date')

  X_train = data_to_train.iloc[:train_size]
  X_test = data_to_train.iloc[train_size:]

  y_train = X_train['sales']
  y_test = X_test['sales']

  return X_train,X_test,y_train,y_test

def arima_try_to_predict(family):
  X_train,X_test,y_train,y_test = prepare_train_data_for(family)

  if is_seasonal[family]:
    model = ARIMA(y_train, order=(p[family], d[family], q[family]),seasonal_order=(p[family], d[family], q[family],52))
  else:
    model = ARIMA(y_train, order=(p[family], d[family], q[family]))

  model_fit = model.fit()
  print(model_fit.summary())

  print(family,y_test.index.min())

  forecast_test = model_fit.predict(start=y_test.index.min(), end=y_test.index.max(),typ="linear")
  forecast_train = model_fit.predict(start=y_train.index.min(), end=y_train.index.max(),typ="linear")

  # Plot predictions
  plt.figure(figsize=(10, 6))
  plt.plot(X_train.index, y_train, label='Train')
  plt.plot(X_test.index, y_test, label='Test')
  plt.plot(X_test.index, forecast_test, label='Test Predictions')
  plt.plot(X_train.index, forecast_train, label='Train Predictions')
  plt.title(f'Sales Forecasting with ARIMA for {family}')
  plt.xlabel('Months')
  plt.ylabel('Sales')
  plt.legend()
  plt.grid(True)
  plt.show()

  # Calculate RMSE
  rmse_test = np.sqrt(mean_squared_error(y_test, forecast_test))
  rmse_train = np.sqrt(mean_squared_error(y_train, forecast_train))
  accuration_test = np.mean(np.where(y_test>=forecast_test, forecast_test/y_test, y_test/forecast_test))

  print('-------------------RMSE-------------------')
  print(f'Test RMSE: {rmse_test}')
  print(f'Train RMSE: {rmse_train}')
  print(f'Accuracy: {accuration_test}')
  print('------------------------------------------\n\n')

  return rmse_test,rmse_train,accuration_test,model_fit,

arima_results = {}

for family in familyScope:
  rmse_test,rmse_train,accuration_test,model = arima_try_to_predict(family)
  arima_results[family] = {
    'rmse_test':rmse_test,
    'rmse_train':rmse_train,
    'accuration_test':accuration_test,
    'model':model,
  }

print(arima_results)

def add_features(raw_data):
  # Extract date
  extract_date = DatetimeFeatures(features_to_extract = ["year", "month",'week','quarter'])
  date_data = extract_date.fit_transform(raw_data[['date']])
  raw_data = pd.concat([raw_data, date_data], axis=1)

  # Add Lag Features
  extract_lag_sales = LagFeatures(periods=[1,2,3,4],drop_original=True)
  lag_sales = extract_lag_sales.fit_transform(raw_data[['sales']])
  raw_data = pd.concat([raw_data, lag_sales], axis=1)

  # Add roll_window features
  raw_data['sales_rolling_5'] = raw_data['sales'].rolling(window=5).mean()
  raw_data['sales_rolling_10'] = raw_data['sales'].rolling(window=10).mean()
  raw_data['sales_rolling_20'] = raw_data['sales'].rolling(window=20).mean()

  raw_data = raw_data.dropna()

  return raw_data

def add_features_to_data(family):
  family_data = filtered_data[family].drop(columns=['index','family'])
  family_data = add_features(family_data)
  return family_data

from sklearn.model_selection import train_test_split

def prepare_train_data_for(family):
  data_to_train = add_features_to_data(family).reset_index()
  data_to_train = data_to_train.set_index('date')
  data_to_train = data_to_train.drop(columns=['index'])

  features = data_to_train.drop(columns=['sales'])
  target = data_to_train['sales']

  X_train, X_test, y_train, y_test = train_test_split(features, target, test_size = 0.2, shuffle = False)

  return X_train,X_test,y_train,y_test

from sklearn.ensemble import RandomForestRegressor

def random_forest_try_to_predict(family):
  X_train,X_test,y_train,y_test = prepare_train_data_for(family)

  RF_regressor = RandomForestRegressor(n_estimators = 300,max_features="sqrt", random_state = 100)
  RF_regressor.fit(X_train, y_train.ravel())

  forecast_test = RF_regressor.predict(X_test)
  forecast_train = RF_regressor.predict(X_train)

  rmse_test = np.sqrt(mean_squared_error(y_test, forecast_test))
  rmse_train = np.sqrt(mean_squared_error(y_train, forecast_train))
  accuration_test = np.mean(np.where(y_test>=forecast_test, forecast_test/y_test, y_test/forecast_test))

  # Plot predictions
  plt.figure(figsize=(10, 6))
  plt.plot(X_train.index, y_train, label='Train')
  plt.plot(X_test.index, y_test, label='Test')
  plt.plot(X_test.index, forecast_test, label='Test Predictions')
  plt.plot(X_train.index, forecast_train, label='Train Predictions')
  plt.title(f'Sales Forecasting with RANDOM FOREST for {family}')
  plt.xlabel('Months')
  plt.ylabel('Sales')
  plt.legend()
  plt.grid(True)
  plt.show()

  print('-------------------RMSE-------------------')
  print(f'Test RMSE: {rmse_test}')
  print(f'Train RMSE: {rmse_train}')
  print(f'Accuracy: {accuration_test}')
  print('------------------------------------------\n\n')

  return rmse_test,rmse_train,accuration_test,RF_regressor

random_forest_results = {}

for family in familyScope:
  rmse_test,rmse_train,accuration_test,model = random_forest_try_to_predict(family)
  random_forest_results[family] = {
    'rmse_test':rmse_test,
    'rmse_train':rmse_train,
    'accuration_test':accuration_test,
    'model':model
  }

print(random_forest_results)

from sklearn.linear_model import Lasso
from sklearn.preprocessing import StandardScaler
from sklearn.pipeline import Pipeline
from sklearn.preprocessing import PolynomialFeatures

# 'AUTOMOTIVE', 'BEAUTY', 'CLEANING', 'EGGS', 'DELI', 'LINGERIE', 'MEATS', 'PREPARED FOODS', 'FROZEN FOODS'

data_scaler = {
    'AUTOMOTIVE':None,
    'LINGERIE':None,
    'CLEANING':MinMaxScaler(feature_range=(0, 1)),
    'DAIRY':MinMaxScaler(feature_range=(0, 1)),
    'DELI':MinMaxScaler(feature_range=(0, 1)),
    'EGGS':None,
    'FROZEN FOODS':MinMaxScaler(feature_range=(0, 1)),
    'MEATS':MinMaxScaler(feature_range=(0, 1)),
    'PREPARED FOODS':MinMaxScaler(feature_range=(0, 1)),
    'BEAUTY':None,
}

def lasso_regression_try_to_predict(family):
  X_train,X_test,y_train,y_test = prepare_train_data_for(family)

  steps = [
    ('scalar', data_scaler[family]),
    ('poly', PolynomialFeatures(degree=3)),
    ('model', Lasso(alpha=0.14, fit_intercept=True, max_iter=3000))
  ]

  lasso_pipe = Pipeline(steps)
  lasso_pipe.fit(X_train, y_train)

  forecast_test = lasso_pipe.predict(X_test)
  forecast_train = lasso_pipe.predict(X_train)

  rmse_test = np.sqrt(mean_squared_error(y_test, forecast_test))
  rmse_train = np.sqrt(mean_squared_error(y_train, forecast_train))
  accuration_test = np.mean(np.where(y_test>=forecast_test, forecast_test/y_test, y_test/forecast_test))

  # Plot predictions
  plt.figure(figsize=(10, 6))
  plt.plot(X_train.index, y_train, label='Train')
  plt.plot(X_test.index, y_test, label='Test')
  plt.plot(X_test.index, forecast_test, label='Test Predictions')
  plt.plot(X_train.index, forecast_train, label='Train Predictions')
  plt.title(f'Sales Forecasting with Lasso Regression for {family}')
  plt.xlabel('Months')
  plt.ylabel('Sales')
  plt.legend()
  plt.grid(True)
  plt.show()

  print('-------------------RMSE-------------------')
  print(f'Test RMSE: {rmse_test}')
  print(f'Train RMSE: {rmse_train}')
  print(f'Accuracy: {accuration_test}')
  print('------------------------------------------\n\n')

  return rmse_test,rmse_train,accuration_test,lasso_pipe

lasso_results = {}

for family in familyScope:
  rmse_test,rmse_train,accuration_test,model = lasso_regression_try_to_predict(family)
  lasso_results[family] = {
    'rmse_test':rmse_test,
    'rmse_train':rmse_train,
    'accuration_test':accuration_test,
    'model':model
  }

print(lasso_results)

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import LSTM, Dense
import tensorflow

import random

# Set seeds
np.random.seed(25)
tensorflow.random.set_seed(25)
random.seed(25)

scaler = MinMaxScaler(feature_range=(0, 1))
look_back = 10

def create_dataset(dataset, look_back=1):
  X, y = [], []
  for i in range(len(dataset) - look_back - 1):
      a = dataset[i:(i + look_back), 0]
      X.append(a)
      y.append(dataset[i + look_back, 0])
  return np.array(X), np.array(y)

def prepare_train_data_for(family):
  family_data = filtered_data[family]
  family_data = family_data[['sales']]

  scaled_data = scaler.fit_transform(family_data)
  X, y = create_dataset(scaled_data, look_back)

  X = np.reshape(X, (X.shape[0], X.shape[1], 1))

  train_size = int(len(X) * 0.67)
  test_size = len(X) - train_size
  X_train, X_test = X[0:train_size], X[train_size:len(X)]
  y_train, y_test = y[0:train_size], y[train_size:len(y)]

  return X_train,X_test,y_train,y_test,scaled_data

def LSTM_try_to_predict(family):
  X_train,X_test,y_train,y_test,scaled_data = prepare_train_data_for(family)

  # Build the LSTM model
  model = Sequential()
  model.add(LSTM(50, return_sequences=True, input_shape=(10, 1)))
  model.add(LSTM(50))
  model.add(Dense(1))

  # Compile the model
  model.compile(loss='mean_squared_error', optimizer='adam')

  # Train the model
  model.fit(X_train, y_train, epochs=10, batch_size=1, verbose=0)

  # Make predictions
  train_predict = model.predict(X_train)
  test_predict = model.predict(X_test)

  # Invert predictions
  train_predict = scaler.inverse_transform(train_predict)
  y_train = scaler.inverse_transform([y_train])
  test_predict = scaler.inverse_transform(test_predict)
  y_test = scaler.inverse_transform([y_test])

  #  Plot the results
  train_plot = np.empty_like(scaled_data)
  train_plot[:, :] = np.nan
  train_plot[look_back:len(train_predict) + look_back, :] = train_predict

  test_plot = np.empty_like(scaled_data)
  test_plot[:, :] = np.nan
  test_plot[len(train_predict) + look_back:len(scaled_data) - 1, :] = test_predict

  plt.figure(figsize=(20, 6))
  plt.plot(scaler.inverse_transform(scaled_data))
  plt.plot(train_plot)
  plt.plot(test_plot)
  plt.show()

  rmse_test = np.sqrt(mean_squared_error(y_test[0], test_predict[:, 0]))
  rmse_train = np.sqrt(mean_squared_error(y_train[0], train_predict[:, 0]))
  accuration_test = np.mean(np.where(y_test[0]>=test_predict[:, 0], test_predict[:, 0]/y_test[0], y_test[0]/test_predict[:, 0]))

  print('-------------------RMSE-------------------')
  print(f'Test RMSE: {rmse_test}')
  print(f'Train RMSE: {rmse_train}')
  print(f'Accuracy: {accuration_test}')
  print('------------------------------------------\n\n')

  return rmse_test,rmse_train,accuration_test,model

lstm_results = {}

for family in familyScope:
  rmse_test,rmse_train,accuration_test,model = LSTM_try_to_predict(family)
  lstm_results[family] = {
    'rmse_test':rmse_test,
    'rmse_train':rmse_train,
    'accuration_test':accuration_test,
    'model':model
  }

print(lstm_results)

results = []

for family in familyScope:

  min_rmse_test   = min(
                      arima_results[family]['rmse_test'],
                      random_forest_results[family]['rmse_test'],
                      lasso_results[family]['rmse_test'],
                      lstm_results[family]['rmse_test']
                    )

  min_rmse_train  = min(
                      arima_results[family]['rmse_train'],
                      random_forest_results[family]['rmse_train'],
                      lasso_results[family]['rmse_train'],
                      lstm_results[family]['rmse_train']
                    )

  best_accuracy   = max(
                      arima_results[family]['accuration_test'],
                      random_forest_results[family]['accuration_test'],
                      lasso_results[family]['accuration_test'],
                      lstm_results[family]['accuration_test']
                    )

  if best_accuracy == arima_results[family]['accuration_test']:
    best_model = 'ARIMA/SARIMA'
  elif best_accuracy == random_forest_results[family]['accuration_test']:
    best_model = 'Random Forest'
  elif best_accuracy == lasso_results[family]['accuration_test']:
    best_model = 'Lasso Regression'
  else:
    best_model = 'LSTM'

  results.append({
    'family':family,

    'best_model':best_model,
    'best_accuracy':best_accuracy,
    'best_rmse_test':min_rmse_test,
    'best_rmse_train':min_rmse_train,

    'accuracy_test_arima':arima_results[family]['accuration_test'],
    'accuracy_test_random_forest':random_forest_results[family]['accuration_test'],
    'accuracy_test_lasso':lasso_results[family]['accuration_test'],
    'accuracy_test_lstm':lstm_results[family]['accuration_test'],

    # 'rmse_test_arima':arima_results[family]['rmse_test'],
    # 'rmse_test_random_forest':random_forest_results[family]['rmse_test'],
    # 'rmse_test_lasso':lasso_results[family]['rmse_test'],
    # 'rmse_test_lstm':lstm_results[family]['rmse_test'],

    # 'rmse_train_arima':arima_results[family]['rmse_train'],
    # 'rmse_train_random_forest':random_forest_results[family]['rmse_train'],
    # 'rmse_train_lasso':lasso_results[family]['rmse_train'],
    # 'rmse_train_lstm':lstm_results[family]['rmse_train'],
  })

result_table = pd.DataFrame(data = results)
result_table

import pickle
from google.colab import files

for family in familyScope:
  best_model = lasso_results[family]['model']
  # Save the model to a file
  with open(f'{family}_best_model.pkl', 'wb') as file:
    pickle.dump(best_model, file)

  files.download(f'{family}_best_model.pkl')

from sklearn.model_selection import train_test_split

def prepare_train_data_for(family):
  data_to_train = add_features_to_data(family).reset_index()
  data_to_train = data_to_train.set_index('date')
  data_to_train = data_to_train.drop(columns=['index'])

  features = data_to_train.drop(columns=['sales'])
  target = data_to_train['sales']

  X_train, X_test, y_train, y_test = train_test_split(features, target, test_size = 0.2, shuffle = False)

  return X_train,X_test,y_train,y_test

for family in familyScope:
  X_train,X_test,y_train,y_test = prepare_train_data_for(family)
  with open(f'/content/{family}_best_model.pkl', 'rb') as file:
    loaded_model = pickle.load(file)
    predictions = loaded_model.predict(X_test)